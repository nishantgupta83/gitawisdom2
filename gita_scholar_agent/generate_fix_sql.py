#!/usr/bin/env python3
"""
Generate PostgreSQL UPDATE statements to fix scenario quality issues
"""
import json
import os
from pathlib import Path

def load_quality_report():
    """Load the quality report JSON"""
    report_path = Path("output/scenario_quality_report.json")
    if not report_path.exists():
        raise FileNotFoundError("Quality report not found. Run scenario_quality_checker.py first.")

    with open(report_path, 'r') as f:
        return json.load(f)

def reconstruct_action_steps(scenario_data):
    """
    Reconstruct properly formatted action steps by merging fragments

    Logic:
    1. If a step has unbalanced open paren, merge with next fragments until closing paren found
    2. If a step is very short (<15 chars), it's likely a fragment - merge with previous
    3. Handle special cases like "etc.)" that clearly belong to previous step
    """
    action_steps = scenario_data['sc_action_steps']
    issues = scenario_data.get('issues', [])

    # Create a map of problematic step indices
    problem_steps = set()
    for issue in issues:
        if 'location' in issue:
            step_idx = int(issue['location'].split()[-1]) - 1  # Convert "step 2" to index 1
            problem_steps.add(step_idx)

    # Reconstruct steps
    fixed_steps = []
    i = 0
    while i < len(action_steps):
        step = action_steps[i]

        # Check if this step has an unbalanced opening parenthesis
        open_count = step.count('(')
        close_count = step.count(')')

        if open_count > close_count:
            # Merge with following fragments until balanced
            merged = step
            j = i + 1
            while j < len(action_steps) and open_count > close_count:
                next_step = action_steps[j]
                # Add comma separator unless it's just closing paren
                if not next_step.strip().startswith(')'):
                    merged += ', ' + next_step
                else:
                    merged += next_step
                open_count += next_step.count('(')
                close_count += next_step.count(')')
                j += 1
            fixed_steps.append(merged)
            i = j
        elif i in problem_steps and len(step.strip()) < 15:
            # This is a fragment - skip it (it should have been merged already)
            i += 1
        else:
            # Normal step
            fixed_steps.append(step)
            i += 1

    return fixed_steps

def escape_sql_string(s):
    """Escape string for SQL"""
    if s is None:
        return 'NULL'
    # Escape single quotes
    return "'" + s.replace("'", "''") + "'"

def generate_update_statement(scenario_data):
    """Generate UPDATE statement for a scenario"""
    scenario_id = scenario_data['id']
    title = scenario_data['sc_title']

    # Get original and fixed action steps
    original_steps = scenario_data['sc_action_steps']
    fixed_steps = reconstruct_action_steps(scenario_data)

    # Format as PostgreSQL array
    array_str = "ARRAY[" + ", ".join([escape_sql_string(step) for step in fixed_steps]) + "]"

    sql = f"""-- Fix: {title}
-- Original steps: {len(original_steps)}, Fixed steps: {len(fixed_steps)}
UPDATE scenarios
SET sc_action_steps = {array_str},
    updated_at = NOW()
WHERE id = {escape_sql_string(scenario_id)};
"""
    return sql, original_steps, fixed_steps

def main():
    print("="*80)
    print("SCENARIO QUALITY FIX SQL GENERATOR")
    print("="*80)
    print()

    # Load quality report
    print("Loading quality report...")
    report = load_quality_report()

    scenarios_with_issues = report['scenarios_with_issues']
    print(f"Found {len(scenarios_with_issues)} scenarios with issues")
    print()

    # Generate output files
    output_dir = Path("output")
    output_dir.mkdir(exist_ok=True)

    sql_file = output_dir / "fix_scenarios.sql"
    report_file = output_dir / "fix_scenarios_report.txt"

    with open(sql_file, 'w') as sql_out, open(report_file, 'w') as report_out:
        # Write SQL header
        sql_out.write("""-- ============================================================================
-- SCENARIO QUALITY FIX SQL STATEMENTS
-- ============================================================================
-- Generated: Auto-generated by generate_fix_sql.py
-- Purpose: Fix fragmented action_steps in scenarios table
-- Issues Fixed: Unbalanced parentheses, fragmented steps, incomplete sentences
--
-- IMPORTANT: Review each UPDATE statement before executing!
-- ============================================================================

BEGIN;

""")

        # Write report header
        report_out.write("="*80 + "\n")
        report_out.write("SCENARIO FIX REPORT\n")
        report_out.write("="*80 + "\n\n")

        total_fixed = 0

        # Process each scenario
        for idx, scenario_data in enumerate(scenarios_with_issues, 1):
            title = scenario_data['sc_title']
            scenario_id = scenario_data['id']
            issue_count = len(scenario_data.get('issues', []))

            print(f"{idx}. Processing: {title} ({issue_count} issues)...")

            try:
                # Generate UPDATE statement
                sql_stmt, original_steps, fixed_steps = generate_update_statement(scenario_data)

                # Write to SQL file
                sql_out.write(sql_stmt)
                sql_out.write("\n")

                # Write to report
                report_out.write(f"\n{'='*80}\n")
                report_out.write(f"{idx}. {title}\n")
                report_out.write(f"ID: {scenario_id}\n")
                report_out.write(f"Issues: {issue_count}\n")
                report_out.write(f"\nORIGINAL ACTION STEPS ({len(original_steps)}):\n")
                for i, step in enumerate(original_steps, 1):
                    report_out.write(f"  {i}. {step}\n")

                report_out.write(f"\nFIXED ACTION STEPS ({len(fixed_steps)}):\n")
                for i, step in enumerate(fixed_steps, 1):
                    report_out.write(f"  {i}. {step}\n")

                report_out.write("\n")

                total_fixed += 1

            except Exception as e:
                error_msg = f"ERROR processing {title}: {e}"
                print(f"  {error_msg}")
                sql_out.write(f"-- {error_msg}\n\n")
                report_out.write(f"\n⚠️ {error_msg}\n\n")

        # Write SQL footer
        sql_out.write("""
COMMIT;

-- ============================================================================
-- END OF FIX STATEMENTS
-- ============================================================================
-- Successfully generated {total_fixed} UPDATE statements
-- Review the fix_scenarios_report.txt file for before/after comparison
-- ============================================================================
""".format(total_fixed=total_fixed))

        # Write report summary
        report_out.write("\n" + "="*80 + "\n")
        report_out.write("SUMMARY\n")
        report_out.write("="*80 + "\n")
        report_out.write(f"Total scenarios fixed: {total_fixed}\n")
        report_out.write(f"Total issues resolved: {sum(len(s.get('issues', [])) for s in scenarios_with_issues)}\n")

    print()
    print("="*80)
    print("✅ Generation complete!")
    print(f"   SQL file: {sql_file}")
    print(f"   Report file: {report_file}")
    print(f"   Scenarios fixed: {total_fixed}")
    print("="*80)

if __name__ == '__main__':
    main()
